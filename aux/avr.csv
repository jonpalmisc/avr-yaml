id,group,mnem,ops,description,lhs,op,rhs,flags
1,arithmetic,add,"Rd, Rr",Add without carry,Rd,set,Rd + Rr,"Z, C, N, V, S, H"
2,arithmetic,adc,"Rd, Rr",Add with carry,Rd,set,Rd + Rr + C,"Z, C, N, V, S, H"
3,arithmetic,adiw,"Rd, K",Add immediate to word,Rd,set,Rd+1:Rd + K,"Z, C, N, V, S"
4,arithmetic,sub,"Rd, Rr",Subtract without carry,Rd,set,Rd - Rr,"Z, C, N, V, S, H"
5,arithmetic,subi,"Rd, K",Subtract immediate,Rd,set,Rd - K,"Z, C, N, V, S, H"
6,arithmetic,sbc,"Rd, Rr",Subtract with carry,Rd,set,Rd - Rr - C,"Z, C, N, V, S, H"
7,arithmetic,sbci,"Rd, K",Subtract immediate with carry,Rd,set,Rd - K - C,"Z, C, N, V, S, H"
8,arithmetic,sbiw,"Rd, K",Subtract immediate from word,Rd+1:Rd,set,Rd+1:Rd - K,"Z, C, N, V, S"
9,arithmetic,and,"Rd, Rr",Logical AND,Rd,set,Rd & Rr,"Z, N, V, S"
10,arithmetic,andi,"Rd, K",Logical AND with immediate,Rd,set,Rd & K,"Z, N, V, S"
11,arithmetic,or,"Rd, Rr",Logical OR,Rd,set,Rd | Rr,"Z, N, V, S"
12,arithmetic,ori,"Rd, K",Logical OR with immediate,Rd,set,Rd | K,"Z, N, V, S"
13,arithmetic,eor,"Rd, Rr",Exclusive OR,Rd,set,Rd ^ Rr,"Z, N, V, S"
14,arithmetic,com,Rd,One’s complement,Rd,set,$FF - Rd,"Z, C, N, V, S"
15,arithmetic,neg,Rd,Two’s complement,Rd,set,$00 - Rd,"Z, C, N, V, S, H"
16,arithmetic,sbr,"Rd, K",Set bit(s) in register,Rd,set,Rd | K,"Z, N, V, S"
17,arithmetic,cbr,"Rd, K",Clear bit(s) in register,Rd,set,Rd & ($FF - K),"Z, N, V, S"
18,arithmetic,inc,Rd,Increment,Rd,set,Rd + 1,"Z, N, V, S"
19,arithmetic,dec,Rd,Decrement,Rd,set,Rd - 1,"Z, N, V, S"
20,arithmetic,tst,Rd,Test for zero or minus,Rd,set,Rd && Rd,"Z, N, V, S"
21,arithmetic,clr,Rd,Clear register,Rd,set,Rd ^ Rd,"Z, N, V, S"
22,arithmetic,ser,Rd,Set register,Rd,set,$FF,
23,arithmetic,mul,"Rd, Rr",Multiply unsigned,R1:R0,set,Rd * Rr (UU),"Z, C"
24,arithmetic,muls,"Rd, Rr",Multiply signed,R1:R0,set,Rd * Rr (SS),"Z, C"
25,arithmetic,mulsu,"Rd, Rr",Multiply signed with unsigned,R1:R0,set,Rd * Rr (SU),"Z, C"
26,arithmetic,fmul,"Rd, Rr",Fractional multiply unsigned,R1:R0,set,Rd * Rr << 1 (UU),"Z, C"
27,arithmetic,fmuls,"Rd, Rr",Fractional multiply signed,R1:R0,set,Rd * Rr << 1 (SS),"Z, C"
28,arithmetic,fmulsu,"Rd, Rr",Fractional multiply signed with unsigned,R1:R0,set,Rd * Rr << 1 (SU),"Z, C"
29,arithmetic,des,K,Data encryption,if (H == 0) R15:R0; if (H == 1) R15:R0,set; set,"Encrypt(R15: R0, K); Decrypt(R15: R0, K)",
30,branch,rjmp,k,Relative jump,PC,set,PC + k + 1,
31,branch,ijmp,,Indirect jump to (Z),PC(15:0); PC(21:16),set; set,Z; 0,
32,branch,eijmp,,Extended indirect jump to (Z),PC(15:0); PC(21:16),set; set,Z; EIND,
33,branch,jmp,k,Jump,PC,set,k,
34,branch,rcall,k,Relative call subroutine,PC,set,PC + k + 1,
35,branch,icall,,Indirect call to (Z),PC(15:0); PC(21:16),set; set,Z; 0,
36,branch,eicall,,Extended indirect call to (Z),PC(15:0); PC(21:16),set; set,Z; EIND,
37,branch,call,k,Call subroutine,PC,set,k,
38,branch,ret,,Subroutine return,PC,set,STACK,
39,branch,reti,,Interrupt return,PC,set,STACK,I
40,branch,cpse,"Rd, Rr","Compare, skip if equal",if (Rd == Rr) PC,set,PC + (2 or 3),
41,branch,cp,"Rd, Rr",Compare,Rd - Rr,,,"Z, C, N, V, S, H"
42,branch,cpc,"Rd, Rr",Compare with carry,Rd - Rr - C,,,"Z, C, N, V, S, H"
43,branch,cpi,"Rd, K",Compare with immediate,Rd - K,,,"Z, C, N, V, S, H"
44,branch,sbrc,"Rr, b",Skip if bit in register cleared,if (Rr(b) == 0) PC,set,PC + (2 or 3),
45,branch,sbrs,"Rr, b",Skip if bit in register set,if (Rr(b) == 1) PC,set,PC + (2 or 3),
46,branch,sbic,"A, b",Skip if bit in I/O register cleared,"if (IO(A, b) == 0) PC",set,PC + (2 or 3),
47,branch,sbis,"A, b",Skip if bit in I/O register set,"If (IO(A, b) == 1) PC",set,PC + (2 or 3),
48,branch,brbs,"s, k",Branch if status flag set,if (SREG(s) == 1) PC,set,PC + k + 1,
49,branch,brbc,"s, k",Branch if status flag cleared,if (SREG(s) == 0) PC,set,PC + k + 1,
50,branch,breq,k,Branch if equal,if (Z == 1) PC,set,PC + k + 1,
51,branch,brne,k,Branch if not equal,if (Z == 0) PC,set,PC + k + 1,
52,branch,brcs,k,Branch if carry set,if (C == 1) PC,set,PC + k + 1,
53,branch,brcc,k,Branch if carry cleared,if (C == 0) PC,set,PC + k + 1,
54,branch,brsh,k,Branch if same or higher,if (C == 0) PC,set,PC + k + 1,
55,branch,brlo,k,Branch if lower,if (C == 1) PC,set,PC + k + 1,
56,branch,brmi,k,Branch if minus,if (N == 1) PC,set,PC + k + 1,
57,branch,brpl,k,Branch if plus,if (N == 0) PC,set,PC + k + 1,
58,branch,brge,k,"Branch if greater or equal, signed",if (N ^ V == 0) PC,set,PC + k + 1,
59,branch,brlt,k,"Branch if less than, signed",if (N ^ V == 1) PC,set,PC + k + 1,
60,branch,brhs,k,Branch if half carry flag set,if (H == 1) PC,set,PC + k + 1,
61,branch,brhc,k,Branch if half carry flag cleared,if (H == 0) PC,set,PC + k + 1,
62,branch,brts,k,Branch if T flag set,if (T == 1) PC,set,PC + k + 1,
63,branch,brtc,k,branch if T flag cleared,if (T == 0) PC,set,PC + k + 1,
64,branch,brvs,k,Branch if overflow flag is set,if (V == 1) PC,set,PC + k + 1,
65,branch,brvc,k,Branch if overflow flag is cleared,if (V == 0) PC,set,PC + k + 1,
66,branch,brie,k,Branch if interrupt enabled,if (I == 1) PC,set,PC + k + 1,
67,branch,brid,k,Branch if interrupt disabled,if (I == 0) PC,set,PC + k + 1,
68,data,mov,"Rd, Rr",Copy register,Rd,set,Rr,
69,data,movw,"Rd, Rr",Copy register pair,Rd+1:Rd,set,Rr+1:Rr,
70,data,ldi,"Rd, K",Load immediate,Rd,set,K,
71,data,lds,"Rd, k",Load direct from data space,Rd,set,(k),
72,data,ld,"Rd, X",Load indirect,Rd,set,(X),
73,data,ld,"Rd, X+",Load indirect and post-increment,Rd; X,set; set,(X); X + 1,
74,data,ld,"Rd, -X",Load indirect and pre-decrement,X; Rd,set; set,X - 1; (X),
75,data,ld,"Rd, Y",Load indirect,Rd,set,(Y),
76,data,ld,"Rd, Y+",Load indirect and post-increment,Rd; Y,set; set,(Y); Y + 1,
77,data,ld,"Rd, -Y",Load indirect and pre-decrement,Y; Rd,set; set,Y - 1; (Y),
78,data,ldd,"Rd, Y+q",Load indirect with displacement,Rd,set,(Y + q),
79,data,ld,"Rd, Z",Load indirect,Rd,set,(Z),
80,data,ld,"Rd, Z+",Load indirect and post-increment,Rd; Z,set; set,(Z); Z+1,
81,data,ld,"Rd, -Z",Load indirect and pre-decrement,Z; Rd,set; set,Z - 1; (Z),
82,data,ldd,"Rd, Z+q",Load indirect with displacement,Rd,set,(Z + q),
83,data,sts,"k, Rr",Store direct to data space,(k),set,Rd,
84,data,st,"X, Rr",Store indirect,(X),set,Rr,
85,data,st,"X+, Rr",Store indirect and post-increment,(X); X,set; set,Rr; X + 1,
86,data,st,"-X, Rr",Store indirect and pre-decrement,X; (X),set; set,X - 1; Rr,
87,data,st,"Y, Rr",Store indirect,(Y),set,Rr,
88,data,st,"Y+, Rr",Store indirect and post-increment,(Y); Y,set; set,Rr; Y + 1,
89,data,st,"-Y, Rr",Store indirect and pre-decrement,Y; (Y),set; set,Y - 1; Rr,
90,data,std,"Y+q, Rr",Store indirect with displacement,(Y+q),set,Rr,
91,data,st,"Z, Rr",Store indirect,(Z),set,Rr,
92,data,st,"Z+, Rr",Store indirect and post-increment,(Z); Z,set; set,Rr; Z + 1,
93,data,st,"-Z, Rr",Store indirect and pre-decrement,Z,set,Z - 1,
94,data,std,"Z+q, Rr",Store indirect with displacement,(Z+q),set,Rr,
95,data,lpm,,Load program memory,R0,set,(Z),
96,data,lpm,"Rd, Z",Load program memory,Rd,set,(Z),
97,data,lpm,"Rd, Z+",Load program memory and post-increment,Rd; Z,set; set,(Z); Z + 1,
98,data,elpm,,Extended load program memory,R0,set,(RAMPZ:Z),
99,data,elpm,"Rd, Z",Extended load program memory,Rd,set,(RAMPZ:Z),
100,data,elpm,"Rd, Z+",Extended load program memory and post-increment,Rd; (RAMPZ:Z),set; set,(RAMPZ:Z); (RAMPZ:Z) + 1,
101,data,spm,,Store program memory,(RAMPZ:Z),set,R1:R0,
102,data,spm,Z+,Store program memory and post-increment by 2,(RAMPZ:Z); Z,set; set,R1:R0; Z + 2,
103,data,in,"Rd, A",In from I/O location,Rd,set,IO(A),
104,data,out,"A, Rr",Out to I/O location,IO(A),set,Rr,
105,data,push,Rr,Push register on stack,STACK,set,Rr,
106,data,pop,Rd,Pop register from stack,Rd,set,STACK,
107,data,xch,"Z, Rd",Exchange,(Z); Rd,set; set,Rd; (Z),
108,data,las,"Z, Rd",Load and set,(Z); Rd,set; set,Rd | (Z); (Z),
109,data,lac,"Z, Rd",Load and clear,(Z); Rd,set; set,($FF - Rd) & (Z); (Z),
110,data,lat,"Z, Rd",Load and toggle,(Z); Rd,set; set,Rd ^ (Z); (Z),
111,bits,lsl,Rd,Logical shift left,Rd(n + 1); Rd(0); C,set; set; set,Rd(n); 0; Rd(7),"Z, C, N, V, H"
112,bits,lsr,Rd,Logical shift right,Rd(n); Rd(7); C,set; set; set,Rd(n + 1); 0; Rd(0),"Z, C, N, V"
113,bits,rol,Rd,Rotate left through carry,Rd(0); Rd(n + 1); C,set; set; set,C; Rd(n); Rd(7),"Z, C, N, V, H"
114,bits,ror,Rd,Rotate right through carry,Rd(7); Rd(n); C,set; set; set,C; Rd(n + 1); Rd(0),"Z, C, N, V"
115,bits,asr,Rd,Arithmetic shift right,Rd(n),set,"Rd(n + 1), n=0..6","Z, C, N, V"
116,bits,swap,Rd,Swap nibbles,Rd(3..0),swap,Rd(7..4),
117,bits,sbi,"A, b",Set bit in I/O register,"IO(A, b)",set,1,
118,bits,cbi,"A, b",Clear bit in I/O register,"IO(A, b)",set,0,
119,bits,bst,"Rr, b",Bit store from register to T,T,set,Rr(b),T
120,bits,bld,"Rd, b",Bit load from T to register,Rd(b),set,T,
121,bits,bset,s,Flag set,SREG(s),set,1,SREG(s)
122,bits,bclr,s,Flag clear,SREG(s),set,0,SREG(s)
123,bits,sec,,Set carry,C,set,1,C
124,bits,clc,,Clear carry,C,set,0,C
125,bits,sen,,Set negative flag,N,set,1,N
126,bits,cln,,Clear negative flag,N,set,0,N
127,bits,sez,,Set zero flag,Z,set,1,Z
128,bits,clz,,Clear zero flag,Z,set,0,Z
129,bits,sei,,Global interrupt enable,I,set,1,I
130,bits,cli,,Global interrupt disable,I,set,0,I
131,bits,ses,,Set signed test flag,S,set,1,S
132,bits,cls,,Clear signed test flag,S,set,0,S
133,bits,sev,,Set two’s complement overflow,V,set,1,V
134,bits,clv,,Clear two’s complement overflow,V,set,0,V
135,bits,set,,Set T in SREG,T,set,1,T
136,bits,clt,,Clear T in SREG,T,set,0,T
137,bits,seh,,Set half carry flag in SREG,H,set,1,H
138,bits,clh,,Clear half carry flag in SREG,H,set,0,H
139,mcu,break,,Break,,,,
140,mcu,nop,,No operation,,,,
141,mcu,sleep,,Sleep,,,,
142,mcu,wdr,,Watchdog reset,,,,